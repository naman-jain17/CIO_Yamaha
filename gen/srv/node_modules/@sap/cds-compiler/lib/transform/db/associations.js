'use strict';

const {
  cloneCsn, forEachGeneric,
  forAllElements,
  getUtils,
} = require('../../model/csnUtils');

const transformUtils = require('../transformUtilsNew');
const { setProp } = require('../../base/model');


/**
 * Return a callback function for forEachDefinition that flattens the foreign keys of managed associations.
 * Foreign keys that are managed associations are replaced by their respective foreign keys.
 *
 * @param {CSN.Model} csn
 * @param {CSN.Options} options
 * @param {string} pathDelimiter
 * @returns {(artifact: CSN.Artifact, artifactName: string) => void} Callback for forEachDefinition
 */
function getForeignKeyFlattener(csn, options, pathDelimiter) {
  const doA2J = !(options.transformation === 'hdbcds' && options.sqlMapping === 'hdbcds');
  const {
    isManagedAssociationElement,
    isStructured,
    inspectRef,
  } = getUtils(csn);

  const {
    flattenStructuredElement,
    flattenStructStepsInRef,
  } = transformUtils.getTransformers(csn, options, pathDelimiter);

  return handleManagedAssociationFKs;

  /**
   * Flatten and create the foreign key elements of managed associaitons
   *
   * @param {CSN.Artifact} art
   * @param {string} artName
   */
  function handleManagedAssociationFKs(art, artName) {
    if ((art.kind === 'entity' || art.kind === 'view') && doA2J) {
      forAllElements(art, artName, (parent, elements, pathToElements) => {
        forEachGeneric(parent, 'elements', (element, elemName) => {
          if (element.keys && isManagedAssociationElement(element)) {
            // replace foreign keys that are managed associations by their respective foreign keys
            flattenFKs(element, elemName, [ ...pathToElements, elemName ]);
          }
        });
      });
    }
  }

  /**
   * Flattens all foreign keys
   *
   * Structures will be resolved to individual elements with scalar types
   *
   * Associations will be replaced by their respective foreign keys
   *
   * If a structure contains an assoc, this will also be resolved and vice versa
   *
   * @param {CSN.Element} assoc
   * @param {string} assocName
   * @param {CSN.Path} path
   */
  function flattenFKs(assoc, assocName, path) {
    let finished = false;
    while (!finished) {
      const newKeys = [];
      finished = processKeys(assoc, assocName, path, newKeys);
      assoc.keys = newKeys;
    }
    assoc.keys = assoc.keys.filter(o => !o.$toDelete);
  }

  /**
   * Walk over the keys and replace structures by their leafs, managed associations by their foreign keys and keep scalar values as-is.
   *
   * @param {CSN.Element} assoc
   * @param {string} assocName
   * @param {CSN.Path} path
   * @param {object[]} collector New keys array to collect the flattened stuff in
   * @returns {boolean} True if all keys are scalar - false if there are things that still need to be processed.
   */
  function processKeys(assoc, assocName, path, collector) {
    let finished = true;
    for (let i = 0; i < assoc.keys.length; i++) {
      const pathToKey = path.concat([ 'keys', i ]);
      const { art } = inspectRef(pathToKey);
      const { ref } = assoc.keys[i];
      if (isStructured(art)) {
        finished = false;
        // Mark this element to filter it later - not needed after expansion
        setProp(assoc.keys[i], '$toDelete', true);
        const flat = flattenStructuredElement(art, ref[ref.length - 1], [], pathToKey);
        Object.keys(flat).forEach((flatElemName) => {
          const key = assoc.keys[i];
          const clone = cloneCsn(assoc.keys[i], options);
          if (clone.as) {
            const lastRef = clone.ref[clone.ref.length - 1];
            // Cut off the last ref part from the beginning of the flat name
            const flatBaseName = flatElemName.slice(lastRef.length);
            // Join it to the existing table alias
            clone.as += flatBaseName;
            // do not loose the $ref for nested keys
            if (key.$ref) {
              let aliasedLeaf = key.$ref[key.$ref.length - 1];
              aliasedLeaf += flatBaseName;
              setProp(clone, '$ref', key.$ref.slice(0, key.$ref.length - 1).concat(aliasedLeaf));
            }
          }
          if (clone.ref) {
            clone.ref[clone.ref.length - 1] = flatElemName;
            // Now we need to properly flatten the whole ref
            clone.ref = flattenStructStepsInRef(clone.ref, pathToKey);
          }
          if (!clone.as)
            clone.as = flatElemName;
          // Directly work on csn.definitions - this way the changes take effect in csnRefs/inspectRef immediately
          // Add the newly generated foreign keys to the end - they will be picked up later on
          // Recursive solutions run into call stack issues
          collector.push(clone);
        });
      }
      else if (art.target) {
        finished = false;
        // Mark this element to filter it later - not needed after expansion
        setProp(assoc.keys[i], '$toDelete', true);
        // Directly work on csn.definitions - this way the changes take effect in csnRefs/inspectRef immediately
        // Add the newly generated foreign keys to the end - they will be picked up later on
        // Recursive solutions run into call stack issues
        art.keys.forEach(key => collector.push(cloneAndExtendRef(key, assoc.keys[i])));
      }
      else if (assoc.keys[i].ref && !assoc.keys[i].as) {
        assoc.keys[i].as = assoc.keys[i].ref[assoc.keys[i].ref.length - 1];
        collector.push(assoc.keys[i]);
      }
      else {
        collector.push(assoc.keys[i]);
      }
    }
    return finished;
  }

  /**
   * Clone base and extend the .ref and .as of the clone with the .ref and .as of ref.
   *
   * @param {object} key A foreign key entry (of a managed assoc as a fk of another assoc)
   * @param {object} base The fk-ref that has key as a fk
   * @returns {object} The clone of base
   */
  function cloneAndExtendRef(key, base) {
    const { ref } = base;
    const clone = cloneCsn(base, options);
    if (key.ref) {
      // We build a ref that contains the aliased fk - that element will be created later on, so this ref is not resolvable yet
      // Therefore we keep it as $ref - ref is the non-aliased, resolvable "clone"
      // Later on, after we know that these foreign key elements are created, we replace ref with this $ref
      let $ref;
      if (base.$ref) {
        // if a base $ref is provided, use it to correctly resolve association chains
        const refChain = [ base.$ref[base.$ref.length - 1] ].concat(key.as || key.ref);
        $ref = base.$ref.slice(0, base.$ref.length - 1).concat(refChain);
      }
      else {
        $ref = base.ref.concat( key.as || key.ref); // Keep along the aliases
      }
      setProp(clone, '$ref', $ref);
      clone.ref = clone.ref.concat(key.ref);
    }

    if (!clone.as && clone.ref && clone.ref.length > 0)
      clone.as = ref[ref.length - 1] + pathDelimiter + (key.as || key.ref.join(pathDelimiter));
    else
      clone.as += pathDelimiter + (key.as || key.ref.join(pathDelimiter));

    return clone;
  }
}


/**
 * Return a callback function for forEachDefinition that
 *
 * @param {CSN.Model} csn
 * @param {CSN.Options} options
 * @param {string} pathDelimiter
 * @param {object} messageFunctions
 * @param {Function} messageFunctions.error
 * @returns {(artifact: CSN.Artifact, artifactName: string) => void} Callback for forEachDefinition
 */
function getForeignKeyElementCreator(csn, options, pathDelimiter, messageFunctions) {
  const { error } = messageFunctions;
  const doA2J = !(options.transformation === 'hdbcds' && options.sqlMapping === 'hdbcds');
  const {
    isManagedAssociationElement,
  } = getUtils(csn);

  const {
    flattenStructStepsInRef, getForeignKeyArtifact,
  } = transformUtils.getTransformers(csn, options, pathDelimiter);


  return createForeignKeyElements;

  /**
   * Create the foreign key elements for managed associations.
   * Create them in-place, right after the corresponding association.
   *
   *
   * @param {CSN.Artifact} art
   * @param {string} artName
   */
  function createForeignKeyElements(art, artName) {
    if ((art.kind === 'entity' || art.kind === 'view') && doA2J) {
      forAllElements(art, artName, (parent, elements, pathToElements) => {
        const elementsArray = [];
        forEachGeneric(parent, 'elements', (element, elemName) => {
          elementsArray.push([ elemName, element ]);
          if (element.keys && isManagedAssociationElement(element)) {
            for (let i = 0; i < element.keys.length; i++) {
              const foreignKey = element.keys[i];
              const path = [ ...pathToElements, elemName, 'keys', i ];
              foreignKey.ref = flattenStructStepsInRef(foreignKey.ref, path);
              const [ fkName, fkElem ] = getForeignKeyArtifact(element, elemName, foreignKey, path);
              if (parent.elements[fkName]) {
                error(null, [ ...pathToElements, elemName ], { name: fkName, art: elemName },
                      'Generated foreign key element $(NAME) for association $(ART) conflicts with existing element');
              }
              else {
                elementsArray.push([ fkName, fkElem ]);
              }
              applyCachedAlias(foreignKey);
              // join ref array as the struct / assoc steps are not necessary anymore
              foreignKey.ref = [ foreignKey.ref.join(pathDelimiter) ];
            }
          }
        });

        // Don't fake consistency of the model by adding empty elements {}
        if (elementsArray.length === 0)
          return;

        parent.elements = elementsArray.reduce((previous, [ name, element ]) => {
          previous[name] = element;
          return previous;
        }, Object.create(null));
      });
    }

    /**
     * We save the aliased representation of the fk in $ref - I suppose to stay resolvable?
     *
     * We now use this $ref for ref and delete it.
     *
     * @param {object} foreignKey
     * @todo With nested projections, we solve similar problems, maybe adapt?
     */
    function applyCachedAlias(foreignKey) {
      // If we have a $ref use that - it resolves aliased FKs correctly
      if (foreignKey.$ref) {
        foreignKey.ref = foreignKey.$ref;
        delete foreignKey.$ref;
      }
    }
  }
}

/**
 * Return a callback function for forEachDefinition that
 *
 * @param {CSN.Model} csn
 * @param {CSN.Options} options
 * @param {string} pathDelimiter
 * @returns {(artifact: CSN.Artifact, artifactName: string) => void} Callback for forEachDefinition
 */
function getManagedAssociationTransformer(csn, options, pathDelimiter) {
  const doA2J = !(options.transformation === 'hdbcds' && options.sqlMapping === 'hdbcds');
  const {
    isManagedAssociationElement,
  } = getUtils(csn);

  return handleAssociations;

  /**
   *
   * Generate foreign keys for managed associations
   * Forbid aliases for foreign keys
   *
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   */
  function handleAssociations(artifact, artifactName) {
    // Do things specific for entities and views (pass 1)
    if (artifact.kind === 'entity' || artifact.kind === 'view') {
      const alreadyHandled = new WeakMap();
      forAllElements(artifact, artifactName, (parent, elements) => {
        for (const elemName in elements) {
          const elem = elements[elemName];
          // (140) Generate foreign key elements and ON-condition for managed associations
          // (unless explicitly asked to keep assocs unchanged)
          if (doA2J && isManagedAssociationElement(elem))
            transformManagedAssociation(parent, artifactName, elem, elemName, alreadyHandled);
        }
      });
    }
  }

  /**
   * Create the foreign key elements for a managed association and build the on-condition
   *
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   * @param {Object} elem The association to process
   * @param {string} elemName
   * @param {WeakMap} alreadyHandled To cache which elements were already processed
   * @returns {void}
   */
  function transformManagedAssociation(artifact, artifactName, elem, elemName, alreadyHandled) {
    // No need to run over this - we already did, possibly because it was referenced in the ON-Condition
    // of another association - see a few lines lower
    if (alreadyHandled.has(elem))
      return;
    // Generate foreign key elements for managed associations, and assemble an ON-condition with them
    const onCondParts = [];
    let joinWithAnd = false;
    if (elem.keys.length === 0) {
      elem._ignore = true;
    }
    else {
      for (const foreignKey of elem.keys) {
        // Assemble left hand side of 'assoc.key = fkey'
        const assocKeyArg = {
          ref: [
            elemName,
          ].concat(foreignKey.ref),
        };
        const fkName = `${elemName}${pathDelimiter}${foreignKey.as}`;
        const fKeyArg = {
          ref: [
            fkName,
          ],
        };

        if (joinWithAnd) { // more than one FK
          onCondParts.push('and');
        }

        onCondParts.push(
          assocKeyArg
        );
        onCondParts.push('=');
        onCondParts.push(fKeyArg);

        if (!joinWithAnd)
          joinWithAnd = true;
      }
      elem.on = onCondParts;
    }

    // If the managed association has a 'key' property => remove it as unmanaged assocs cannot be keys
    // TODO: Are there other modifiers (like 'key') that are valid for managed, but not valid for unmanaged assocs?
    if (elem.key)
      delete elem.key;


    // If the managed association has a 'not null' property => remove it
    if (elem.notNull)
      delete elem.notNull;


    // The association is now unmanaged, i.e. actually it should no longer have foreign keys
    // at all. But the processing of backlink associations below expects to have them, so
    // we don't delete them (but mark them as implicit so that toCdl does not render them)

    // Remember that we already processed this
    alreadyHandled.set(elem, true);
  }
}


module.exports = {
  getForeignKeyFlattener,
  getForeignKeyElementCreator,
  getManagedAssociationTransformer,
};
