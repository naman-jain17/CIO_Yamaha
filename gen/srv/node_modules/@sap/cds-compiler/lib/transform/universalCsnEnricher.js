'use strict';

const { setProp } = require('../base/model');
const {
  forEachDefinition,
  forAllQueries,
  getUtils,
  forEachMember,
  forEachMemberRecursively,
} = require('../model/csnUtils');

/**
 * Loop through a universal CSN and enrich it with the properties/annotations
 * from the source definition - modifies the input model in-place
 *
 * @param {CSN.Model} csn
 * @param {CSN.Options} options
 */
module.exports = function (csn, options) {
  let { getOrigin, getQueryPrimarySource, artifactRef } = getUtils(csn);

  // Properties on definition level that we treat specially.
  // TODO: There might be more annotations that will need special treatment
  // see lib/compiler/propagator.js for reference
  const defProps = {
    '@cds.autoexpose': onlyViaArtifact,
    '@fiori.draft.enabled': onlyViaArtifact,
    '@': (prop, target, source) => { target[prop] = source[prop] },
    // Example: `type E : F;` does not have `elements`, but they are required for e.g. OData.
    'elements': onlyTypeDef,
  }

  // In this first loop through the model, missing properties in universal CSN
  // are propagated so the CSN can become client one
  forEachDefinition(csn, propagate);

  // The $origin properties need to be removed separately
  // as the values are used in csnRef::getOrigin that is used during
  // the propagation above.
  // Currently testMode-only for comparison against client CSN.
  if (options.testMode) removeDollarProperties(csn);

  /**
   * Identify the sources of the passed object and propagate the relevant
   * properties/annotations.
   *
   * @param {Object} art Target object for propagation
   */
  function propagate(art) {
    // check if art was already processed by the status flag
    // TODO: clean up later on, together with validator clean up probably or
    //       when this module is meant to be used standalone -> use internal cache to store already processed definitions?
    if (art._status === 'propagated') return;

    // collect chain of origins and propagate
    // from the farthest to the nearest one to the target
    let chain = [];
    let target = art;
    let origin = undefined;
    do {
      origin = getOrigin(target);
      if (origin) {
        chain.push({ target, origin });
        target = origin;
      }
    } while (origin);

    if (chain.length)
      chain.reverse().forEach(propagateSingleStep);
    else
      // even if there weren't any found origin(s) on definition level
      // we need to loop through the members
      // TODO: construct use-/test-case where there might be the need that an origin chain
      //       needs to be constructed for members as well, specifically for this 'else'
      //       case where we do not run through the definitions
      propagateMembersProps(target);

    function propagateSingleStep({ target, origin }) {
      // if target was already processed -> continue
      if (target._status === 'propagated') return;
      // propagate relevant definition level properties
      // we check for kind as in the future the function should be
      // generic and work for parts of CSN
      if (target.kind) propagateDefProps(target, origin);
      // propagate properties to members
      propagateMembersProps(target);

      setProp(target, '_status', 'propagated');
    }

    /**
     * Propagate from 'source' to 'target' the relevant properties
     * for CSN definitions.
     *
     * @param {CSN.Definition} target
     * @param {CSN.Definition} source
     */
    function propagateDefProps(target, source) {
      const keys = Object.keys(source);
      for (const prop of keys) {
        // do not overwrite properties in target def
        if (!(prop in target)) {
          const func = defProps[prop] || defProps[prop.charAt(0)];
          if (func) func(prop, target, source);
        }
      }
    }

    /**
     * Propagate properties from Universal to Client CSN relevant for members.
     *
     * @param {CSN.Artifact} target
     */
    function propagateMembersProps(target) {
      // TODO: in the future, consider case when target is a member itself,
      //       for when we do not run with the complete CSN
      // TODO: use newly added 'forEachMemberRecursivelyWithQuery'
      forEachMemberRecursively(target, (member) => {
        propagateMemberPropsFromOrigin(member);
        if (member.target && !member.keys && !member.on)
          calculateForeignKeys(member);
      });
      target.query && forAllQueries(target.query, (query) => {
        if (query.SELECT && query.SELECT.elements) {
          forEachMember(query.SELECT, (member) => {
            propagateMemberPropsFromOrigin(member);
            if (member.target && !member.keys && !member.on)
              calculateForeignKeys(member);
          });
        }
      });
      setProp(target, '_status', 'propagated');
    }

    function propagateMemberPropsFromOrigin(member) {
      // For empty members (`{}`), the origin was set in a previous call to `getOrigin(definition)`.
      const memberOrigin = getOrigin(member);
      if (!memberOrigin) return;

      // when having an element with a type property that is
      // user-defined there is no need to propagate 'elements',
      // 'kind', etc. from the origin (which is the type definition)
      if (member.type && Object.keys(member).length === 1) return;

      const keys = Object.keys(memberOrigin);
      // Copy over properties from the origin element.
      // Don't propagate "kind" as this property is not allowed in elements.
      for (const key of keys) {
        if (!(key in member) && key !== 'kind')
          member[key] = memberOrigin[key];
      }

      // copy over own annotations/properties
      // TODO: try to create use-/test-case where this needs
      //       to be applied on definition level, ATM it is done only for members
      if (member.$origin && !Array.isArray(member.$origin) && member.$origin.$origin) {
        const ownKeys = Object.keys(member.$origin);
        for (const key of ownKeys) {
          if (key !== '$origin')
            member[key] = member.$origin[key];
        }
      }

      // In case of managed composition an anonymous $origin is used.
      // csnRefs::getOrigin returns {} for such a member, thus have to recreate the client CSN from
      // the values in the $origin. PR #8072
      if (!Object.keys(memberOrigin).length && member.$origin && member.$origin.type === 'cds.Composition') {
        member.type = member.$origin.type;
        member.cardinality = member.$origin.cardinality;
        member.targetAspect = member.$origin.target;
      }
    }

    function calculateForeignKeys(member) {
      // managed assocs in universal CSN have no longer keys
      // if they are not explicitly defined - PR#8064
      const target = artifactRef(member.target);
      const targetKeys = Object.keys(target.elements).filter((key) => target.elements[key].key);
      member.keys = targetKeys.map(
        keyName => { return { ref: [keyName] } }
      );
    }

  }

  /**
   * @cds.autoexpose for example, is propagated only if at definition level and only if
   * the primary source (left-most) does not follow an association.
   *
   * @param {String} prop
   * @param {CSN.Definition} target
   * @param {CSN.Definition} source
   */
  function onlyViaArtifact(prop, target, source) {
    if (!target.kind) return;
    const primarySourceRef = getQueryPrimarySource(target.query || target.projection);
    const artRef = primarySourceRef ? artifactRef(primarySourceRef) : source;
    if (!artRef.target) {
      target[prop] = source[prop];
    }
  }

  /**
   * Execute only if the target definition is a user-defined type.
   *
   * @param {String} prop
   * @param {CSN.Definition} target
   * @param {CSN.Definition} source
   * @returns
   */
  function onlyTypeDef(prop, target, source) {
    if (target.kind !== 'type') return;
    target[prop] = source[prop];
  }

  /**
   * Removes every occurrence of '$origin' and '$generated'
   * for compatibility with what we have in client CSN.
   *
   * @param {CSN.Model} csn
   */
  function removeDollarProperties(csn) {
    forEachDefinition(csn, (def) => {
      delete def.$origin;
      delete def.$generated;
      // TODO: use newly added 'forEachMemberRecursivelyWithQuery'
      forEachMemberRecursively(def, (member) => delete member.$origin);
      def.query && forAllQueries(def.query, (query) => {
        if (query.SELECT && query.SELECT.elements) {
          forEachMember(query.SELECT, (member) => {
            delete member.$origin;
          });
        }
      });
    })
  }
}
